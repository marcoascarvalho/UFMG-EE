CCS PCW C Compiler, Version 2.529, 4460

               Filename: E:\BOC\ROBONO~1\2000\PROGRAM\NEW\MAIN.LST

               ROM used: 1283 (31%)
                         1283 (31%) including unused fragments
               RAM used: 33 (17%) at main() level
                         38 (20%) worst case
               Stack:    6 worst case (4 in main + 2 for interrupts)

0000:  MOVLW  00
0001:  MOVWF  0A
0002:  GOTO   43C
0003:  NOP
0004:  BTFSS  0A,3
0005:  BCF    0A,4
0006:  BTFSC  0A,3
0007:  BSF    0A,4
0008:  BCF    0A,3
0009:  BTFSC  03,5
000A:  GOTO   00F
000B:  MOVWF  25
000C:  SWAPF  03,W
000D:  MOVWF  26
000E:  GOTO   014
000F:  BCF    03,5
0010:  MOVWF  25
0011:  SWAPF  03,W
0012:  MOVWF  26
0013:  BSF    26,1
0014:  SWAPF  25,F
0015:  MOVF   04,W
0016:  MOVWF  27
0017:  MOVF   20,W
0018:  MOVWF  28
0019:  MOVF   21,W
001A:  MOVWF  29
001B:  MOVF   22,W
001C:  MOVWF  2A
001D:  MOVF   23,W
001E:  MOVWF  2B
001F:  MOVF   24,W
0020:  MOVWF  2C
0021:  BCF    03,5
0022:  BTFSS  0B,5
0023:  GOTO   026
0024:  BTFSC  0B,2
0025:  GOTO   03C
0026:  MOVF   27,W
0027:  MOVWF  04
0028:  MOVF   28,W
0029:  MOVWF  20
002A:  MOVF   29,W
002B:  MOVWF  21
002C:  MOVF   2A,W
002D:  MOVWF  22
002E:  MOVF   2B,W
002F:  MOVWF  23
0030:  MOVF   2C,W
0031:  MOVWF  24
0032:  BTFSC  0A,4
0033:  BSF    0A,3
0034:  BCF    0A,4
0035:  SWAPF  26,W
0036:  MOVWF  03
0037:  BCF    03,5
0038:  SWAPF  25,W
0039:  BTFSC  26,1
003A:  BSF    03,5
003B:  RETFIE
003C:  BCF    0A,3
003D:  GOTO   051
....................  /**************************************************************************/ 
.................... /*        Programa principal BOCBoard - main.c                            */ 
.................... /* Autor: Marco Antonio Santuci Carvalho                                  */ 
.................... /* Ultima modificacao: 08/06/2000                                         */ 
.................... /* Descricao: este é o programa principal que controla a placa BOCboard   */ 
.................... /*                                                                        */ 
.................... /*                                                                        */ 
.................... /**************************************************************************/ 
....................  
.................... #INCLUDE "MAIN.H" 
....................   /**************************************************************************/ 
.................... /*        Programa cabecalho BOCBoard - main.h                            */ 
.................... /* Autor: Marco Antonio Santuci Carvalho                                  */ 
.................... /* Ultima modificacao: 30/05/2000                                         */ 
.................... /* Descricao: este é o programa de cabecalho que controla a placa         */ 
.................... /* BOCboard. Contem definicao de constantes e nome de pinos.              */ 
.................... /*                                                                        */ 
.................... /**************************************************************************/ 
....................  
.................... #device PIC16C74A 
.................... #use delay(clock=20000000) 
.................... #list 
.................... 
.................... #INCLUDE "9366.C" 
....................  /////////////////////////////////////////////////////////////////////////// 
.................... ////   Library for a MicroChip 93C66 configured for a x8 org           //// 
.................... ////                                                                   //// 
.................... ////   init_ext_eeprom();    Call before the other functions are used  //// 
.................... ////                                                                   //// 
.................... ////   write_ext_eeprom(a, d);  Write the byte d to the address a      //// 
.................... ////                                                                   //// 
.................... ////   d = read_ext_eeprom(a);   Read the byte d from the address a    //// 
.................... ////                                                                   //// 
.................... ////   The main program may define eeprom_select, eeprom_di, eeprom_do //// 
.................... ////   and eeprom_clk to override the defaults below.                  //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,1997 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef EEPROM_SELECT 
....................  
.................... #define EEPROM_SELECT PIN_B7 
.................... #define EEPROM_CLK    PIN_B6 
.................... #define EEPROM_DI     PIN_B5 
.................... #define EEPROM_DO     PIN_B4 
....................  
.................... #endif 
....................  
.................... #define EEPROM_ADDRESS long int 
.................... #define EEPROM_SIZE    512 
....................  
.................... #define hi(x)  (*(&x+1)) 
....................  
....................  
.................... void init_ext_eeprom() { 
....................    byte cmd[2]; 
....................    byte i; 
....................  
....................    output_low(EEPROM_DI); 
*
0063:  BCF    2D,4
0064:  MOVF   2D,W
0065:  TRIS   7
0066:  BCF    07,4
....................    output_low(EEPROM_CLK); 
0067:  BCF    2D,3
0068:  MOVF   2D,W
0069:  TRIS   7
006A:  BCF    07,3
....................    output_low(EEPROM_SELECT); 
006B:  MOVLW  E8
006C:  BSF    03,5
006D:  MOVWF  09
006E:  BCF    03,5
006F:  BCF    09,2
....................  
....................    cmd[0]=0xc0; 
0070:  MOVLW  C0
0071:  MOVWF  40
....................    cmd[1]=0x4; 
0072:  MOVLW  04
0073:  MOVWF  41
....................  
....................    for(i=1;i<=5;++i) 
0074:  MOVLW  01
0075:  MOVWF  42
0076:  MOVLW  06
0077:  SUBWF  42,W
0078:  BTFSC  03,0
0079:  GOTO   07F
....................       shift_left(cmd,2,0); 
007A:  BCF    03,0
007B:  RLF    40,F
007C:  RLF    41,F
007D:  INCF   42,F
007E:  GOTO   076
....................    output_high(EEPROM_SELECT); 
007F:  MOVLW  E8
0080:  BSF    03,5
0081:  MOVWF  09
0082:  BCF    03,5
0083:  BSF    09,2
....................    for(i=1;i<=12;++i) { 
0084:  MOVLW  01
0085:  MOVWF  42
0086:  MOVLW  0D
0087:  SUBWF  42,W
0088:  BTFSC  03,0
0089:  GOTO   09F
....................       output_bit(EEPROM_DI, shift_left(cmd,2,0)); 
008A:  BCF    03,0
008B:  RLF    40,F
008C:  RLF    41,F
008D:  BTFSC  03,0
008E:  GOTO   091
008F:  BCF    07,4
0090:  GOTO   092
0091:  BSF    07,4
0092:  BCF    2D,4
0093:  MOVF   2D,W
0094:  TRIS   7
....................       output_high(EEPROM_CLK); 
0095:  BCF    2D,3
0096:  MOVF   2D,W
0097:  TRIS   7
0098:  BSF    07,3
....................       output_low(EEPROM_CLK); 
0099:  BCF    2D,3
009A:  MOVF   2D,W
009B:  TRIS   7
009C:  BCF    07,3
....................    } 
009D:  INCF   42,F
009E:  GOTO   086
....................    output_low(EEPROM_DI); 
009F:  BCF    2D,4
00A0:  MOVF   2D,W
00A1:  TRIS   7
00A2:  BCF    07,4
....................    output_low(EEPROM_SELECT); 
00A3:  MOVLW  E8
00A4:  BSF    03,5
00A5:  MOVWF  09
00A6:  BCF    03,5
00A7:  BCF    09,2
00A8:  BCF    0A,3
00A9:  GOTO   470
.................... } 
....................  
....................  
.................... void write_ext_eeprom(EEPROM_ADDRESS address, byte data) { 
....................    byte cmd[3]; 
....................    byte i; 
....................  
....................    cmd[0]=data; 
....................    cmd[1]=(byte)address; 
....................    cmd[2]=0xa|hi(address); 
....................  
....................    for(i=1;i<=4;++i) 
....................       shift_left(cmd,3,0); 
....................    output_high(EEPROM_SELECT); 
....................    for(i=1;i<=20;++i) { 
....................       output_bit(EEPROM_DI, shift_left(cmd,3,0)); 
....................       output_high(EEPROM_CLK); 
....................       output_low(EEPROM_CLK); 
....................    } 
....................    output_low(EEPROM_DI); 
....................    output_low(EEPROM_SELECT); 
....................    delay_ms(11); 
.................... } 
....................  
....................  
.................... byte read_ext_eeprom(EEPROM_ADDRESS address) { 
....................    byte cmd[3]; 
....................    byte i,data; 
....................  
....................    cmd[0]=0; 
....................    cmd[1]=(byte)address; 
....................    cmd[2]=0xc|hi(address); 
....................  
....................    for(i=1;i<=4;++i) 
....................       shift_left(cmd,3,0); 
....................    output_high(EEPROM_SELECT); 
....................    for(i=1;i<=20;++i) { 
....................       output_bit(EEPROM_DI, shift_left(cmd,3,0)); 
....................       output_high(EEPROM_CLK); 
....................       output_low(EEPROM_CLK); 
....................       if(i>12) 
....................         shift_left(&data,1,input(EEPROM_DO)); 
....................    } 
....................    output_low(EEPROM_SELECT); 
....................    return(data); 
.................... } 
.................... 
....................  
....................  
.................... /***********************************************************************/ 
.................... /*             Declaração das Variáveis Globais                        */ 
.................... /***********************************************************************/ 
....................  
....................  byte id;                   // Identificacao do robo-> lido na EEPROM 
....................  byte i, contbyte;          // Contadores 
....................  byte serial; 
....................  boolean lowbat;            // Flag de bateria 
....................  boolean notrx;             // Flag de falta de dado 
....................  boolean wrongdata;         // Flag de dado errado 
....................  boolean setpoint;          // Flag de dado setpoint ou parametros 
....................  boolean pisca=0; 
....................  byte kp, ki, kd;           // Ganhos do Controlador 
....................  
....................  byte sp1_acel_serial, sp1_vel_serial, sp1_pos_serial, 
....................       sp2_acel_serial, sp2_vel_serial, sp2_pos_serial; // Set-Points dos motores programado vindos da serial 
....................  
....................  //float sp1_pos, sp2_pos;    // Set point de posicao a ser enviado para o LM629 
....................  
....................  //long int sp1_vel, sp2_vel, sp1_acel, sp2_acel; // set point de velocidade e aceleracao a ser enviado para LM629 
....................  
....................  BYTE time_exec; 
.................... /**********************************************************************/ 
....................  
.................... /***********************************************************************/ 
.................... /*                 Declaração de constantes                            */ 
.................... /***********************************************************************/ 
.................... #DEFINE CTRL1   1 
.................... #DEFINE CTRL2   0 
....................  
.................... #DEFINE ALL_IN   0XFF 
.................... #DEFINE ALL_OUT  0X00 
....................  
.................... #DEFINE N_LINHAS_ENCODER 16 
.................... #DEFINE RESOLUCAO  N_LINHAS_ENCODER*4 
....................  
.................... #DEFINE MAX_TIME 100; 
....................  
.................... #INCLUDE "bateria.c" 
....................   
.................... /**************************************************************************/ 
.................... /*        Rotinas para tratamento da medicao de bateria - bateria.c       */ 
.................... /* Autor: Marco Antonio Santuci Carvalho                                  */ 
.................... /* Ultima modificacao: 23/05/2000                                         */ 
.................... /**************************************************************************/ 
....................  
.................... /**************************************************************************/ 
.................... /* Rotina p/ verificar nivel de tensao na bateria                         */ 
.................... /*                                                                        */ 
.................... /* Descricao: esta rotina verifica a tensao na bateria atraves da leitura */ 
.................... /*            do canal 0(pino RA0) do conversor A/D do PIC. Retorna TRUE  */ 
.................... /**************************************************************************/ 
.................... void bateria(void) 
.................... { 
....................    int value; 
....................  
....................      set_adc_channel( 0 ); 
....................      value=read_adc(); 
....................      if (value>102) {  // 102= (5.75V/2/7.2V)*256 
....................          lowbat=FALSE; 
....................          output_high(LED1_RED);     // Apaga Led vermelho 
....................          } 
....................      else  lowbat=TRUE; 
.................... } 
....................  
.................... void battery_check(void) 
.................... { 
....................  
.................... bateria(); 
.................... if (lowbat) 
....................    {                      // Se bateria boa(>5.75V) 
....................    output_low(LED1_RED);  // Acende Led vermelho 
....................    }//if 
....................  
.................... } 
.................... 
.................... #INCLUDE "leds.c" 
....................  /**************************************************************************/ 
.................... /*        Rotinas para sinalizacao atraves dos leds - leds.c              */ 
.................... /* Autor: Marco Antonio Santuci Carvalho                                  */ 
.................... /* Ultima modificacao: 05/06/2000                                         */ 
.................... /**************************************************************************/ 
....................  
.................... #DEFINE TIME_LED 500 
....................  
.................... #INLINE 
.................... acende_led_vermelho() 
.................... { 
....................  output_low(LED1_RED);  
.................... } 
....................  
.................... apaga_led_vermelho() 
.................... { 
....................  output_high(LED1_RED); 
.................... }  
....................  
.................... acende_led_amarelo() 
.................... { 
....................  output_low(LED2_YELLOW);  
*
02BB:  BSF    03,5
02BC:  BCF    06,2
02BD:  BCF    03,5
02BE:  BCF    06,2
02BF:  BCF    0A,3
02C0:  GOTO   49C
.................... } 
....................  
.................... apaga_led_amarelo() 
.................... { 
....................  output_high(LED2_YELLOW); 
02C1:  BSF    03,5
02C2:  BCF    06,2
02C3:  BCF    03,5
02C4:  BSF    06,2
02C5:  BCF    0A,3
02C6:  GOTO   4AB
.................... }  
....................  
.................... acende_led_verde() 
.................... { 
....................  output_low(LED3_GREEN);  
*
0159:  BSF    03,5
015A:  BCF    05,2
015B:  BCF    03,5
015C:  BCF    05,2
015D:  RETLW  00
.................... } 
....................  
.................... apaga_led_verde() 
.................... { 
....................  output_high(LED3_GREEN); 
015E:  BSF    03,5
015F:  BCF    05,2
0160:  BCF    03,5
0161:  BSF    05,2
0162:  RETLW  00
.................... }  
....................  
.................... /***********************************************************************/ 
.................... /*                 Rotina para apagar leds                             */ 
.................... /***********************************************************************/ 
.................... void leds_off(void) 
.................... { 
....................  output_high(LED1_RED);   // Led 1 
....................  output_high(LED2_YELLOW);   // Led 2 
....................  output_high(LED3_GREEN);   // Led 3 
.................... } 
....................  
.................... /***********************************************************************/ 
.................... /*                 Rotina para acender leds                            */ 
.................... /***********************************************************************/ 
.................... void leds_on(void) 
.................... { 
....................   output_low(LED1_RED);    // Led 1 
....................   output_low(LED2_YELLOW);    // Led 2 
....................   output_low(LED3_GREEN);    // Led 3 
.................... } 
....................  
.................... /***********************************************************************/ 
.................... /*                 Rotina de inicializacao com leds                     */ 
.................... /***********************************************************************/ 
....................  
.................... void inicia_leds(void) 
.................... { 
....................  leds_off(); 
....................  delay_ms(TIME_LED); 
....................  leds_on(); 
....................  delay_ms(TIME_LED); 
....................  leds_off(); 
....................  delay_ms(TIME_LED); 
....................  leds_on(); 
....................  delay_ms(TIME_LED); 
....................  leds_off(); 
....................  delay_ms(TIME_LED); 
....................  } 
....................   
.................... 
.................... #INCLUDE "629ctrl.c" 
....................  /**************************************************************************/ 
.................... /*        Rotinas de controle LM629 - 629ctrl.c                           */ 
.................... /* Autor: Marco Antonio Santuci Carvalho                                  */ 
.................... /* Ultima modificacao: 20/05/2000                                         */ 
.................... /* Descricao: Esta biblioteca de funcoes implementa funcoes de uso        */ 
.................... /*            do LM629 tais como leitura do byte de status e escritas no  */ 
.................... /*            barramento de comando e dados.                              */ 
.................... /**************************************************************************/ 
....................  
.................... /**************************************************************************/ 
.................... /* Rotina de leitura do byte de status do LM629                           */ 
.................... /*                                                                        */ 
.................... /* Descricao: esta rotina faz a leitura do byte de status do LM629 de     */ 
.................... /*            acordo com o controlador passado para a funcao. O byte de   */ 
.................... /*            Status indica:                                              */ 
.................... /*            Bit 7 - Motor Off                                           */ 
.................... /*            Bit 6 - Breakpoint Reached(Interrupt)                       */ 
.................... /*            Bit 5 - Excessive Position Error(Interrupt)                 */ 
.................... /*            Bit 4 - Wraparound Ocurred(Interrupt)                       */ 
.................... /*            Bit 3 - Index Pulse Observed(Interrupt)                     */ 
.................... /*            Bit 2 - Trajectory Complete(Interrupt)                      */ 
.................... /*            Bit 1 - Command Error(Interrupt)                            */ 
.................... /*            Bit 0 - Busy Bit                                            */ 
.................... /**************************************************************************/ 
.................... byte read_status(boolean controler)  // Le o byte de estatus 
.................... { 
....................    byte status; 
....................    if (controler){ 
*
00AA:  MOVF   44,F
00AB:  BTFSC  03,2
00AC:  GOTO   0B6
....................       output_high(LM629_CS2);      // Desabilita o controlador 2 
00AD:  BCF    2D,0
00AE:  MOVF   2D,W
00AF:  TRIS   7
00B0:  BSF    07,0
....................       output_low(LM629_CS1);       // Habilita o controlador 1 
00B1:  BCF    2D,1
00B2:  MOVF   2D,W
00B3:  TRIS   7
00B4:  BCF    07,1
....................       } 
....................    else{ 
00B5:  GOTO   0BE
....................       output_high(LM629_CS1);      // Desabilita o controlador 1 
00B6:  BCF    2D,1
00B7:  MOVF   2D,W
00B8:  TRIS   7
00B9:  BSF    07,1
....................       output_low(LM629_CS2);       // Habilita o controlador 2 
00BA:  BCF    2D,0
00BB:  MOVF   2D,W
00BC:  TRIS   7
00BD:  BCF    07,0
....................       } 
....................    output_low(LM629_PS); 
00BE:  MOVLW  E8
00BF:  BSF    03,5
00C0:  MOVWF  09
00C1:  BCF    03,5
00C2:  BCF    09,1
....................    output_low(LM629_RD); 
00C3:  BSF    03,5
00C4:  BCF    05,5
00C5:  BCF    03,5
00C6:  BCF    05,5
....................    SET_TRIS_D(0xFF);         // PortD=input 
00C7:  MOVLW  FF
00C8:  BSF    03,5
00C9:  MOVWF  08
....................    status=dados; 
00CA:  BCF    03,5
00CB:  MOVF   08,W
00CC:  MOVWF  45
....................    output_high(LM629_RD); 
00CD:  BSF    03,5
00CE:  BCF    05,5
00CF:  BCF    03,5
00D0:  BSF    05,5
....................    output_high(LM629_PS); 
00D1:  MOVLW  E8
00D2:  BSF    03,5
00D3:  MOVWF  09
00D4:  BCF    03,5
00D5:  BSF    09,1
....................    output_high(LM629_CS1); 
00D6:  BCF    2D,1
00D7:  MOVF   2D,W
00D8:  TRIS   7
00D9:  BSF    07,1
....................    output_high(LM629_CS2); 
00DA:  BCF    2D,0
00DB:  MOVF   2D,W
00DC:  TRIS   7
00DD:  BSF    07,0
....................  
....................    return status; 
00DE:  MOVF   45,W
00DF:  MOVWF  21
00E0:  RETLW  00
.................... } 
....................  
....................  
.................... /**************************************************************************/ 
.................... /* Rotina de escrita de comandos no LM629                                 */ 
.................... /*                                                                        */ 
.................... /* Descricao: esta rotina escreve uma instrucao na porta de comando do    */ 
.................... /*            LM629. A seguinte sequencia eh utilizada:                   */ 
.................... /*            LM629_PS=0 (Port status = 0 --> comando);                         */ 
.................... /*            LM629_WR=0; CS=0.                                                 */ 
.................... /**************************************************************************/ 
.................... void LM629_write_command(boolean controler, byte byte1) 
.................... { 
....................   if (controler){ 
*
00F3:  MOVF   43,F
00F4:  BTFSC  03,2
00F5:  GOTO   0FF
....................       output_high(LM629_CS2);      // Desabilita o controlador 2 
00F6:  BCF    2D,0
00F7:  MOVF   2D,W
00F8:  TRIS   7
00F9:  BSF    07,0
....................       output_low(LM629_CS1);       // Habilita o controlador 1 
00FA:  BCF    2D,1
00FB:  MOVF   2D,W
00FC:  TRIS   7
00FD:  BCF    07,1
....................       } 
....................    else{ 
00FE:  GOTO   107
....................       output_high(LM629_CS1);      // Desabilita o controlador 1 
00FF:  BCF    2D,1
0100:  MOVF   2D,W
0101:  TRIS   7
0102:  BSF    07,1
....................       output_low(LM629_CS2);       // Habilita o controlador 2 
0103:  BCF    2D,0
0104:  MOVF   2D,W
0105:  TRIS   7
0106:  BCF    07,0
....................       } 
....................    output_low(LM629_PS); 
0107:  MOVLW  E8
0108:  BSF    03,5
0109:  MOVWF  09
010A:  BCF    03,5
010B:  BCF    09,1
....................    SET_TRIS_D(0x00);         // PortD = Output 
010C:  MOVLW  00
010D:  BSF    03,5
010E:  MOVWF  08
....................    dados=byte1; 
010F:  BCF    03,5
0110:  MOVF   44,W
0111:  MOVWF  08
....................    output_low(LM629_WR); 
0112:  MOVLW  E8
0113:  BSF    03,5
0114:  MOVWF  09
0115:  BCF    03,5
0116:  BCF    09,0
....................    output_high(LM629_WR); 
0117:  BSF    03,5
0118:  MOVWF  09
0119:  BCF    03,5
011A:  BSF    09,0
....................    output_high(LM629_PS); 
011B:  BSF    03,5
011C:  MOVWF  09
011D:  BCF    03,5
011E:  BSF    09,1
....................    output_high(LM629_CS1); 
011F:  BCF    2D,1
0120:  MOVF   2D,W
0121:  TRIS   7
0122:  BSF    07,1
....................    output_high(LM629_CS2); 
0123:  BCF    2D,0
0124:  MOVF   2D,W
0125:  TRIS   7
0126:  BSF    07,0
0127:  RETLW  00
.................... } 
....................  
....................  
.................... /**************************************************************************/ 
.................... /* Rotina de escrita de dados no LM629                                    */ 
.................... /*                                                                        */ 
.................... /* Descricao: esta rotina escreve uma instrucao na porta de dados do      */ 
.................... /*            LM629. A seguinte sequencia eh utilizada:                   */ 
.................... /*            LM629_PS=1 (Port status = 1 --> dado);                            */ 
.................... /*            LM629_WR=0; CS=0.                                                 */ 
.................... /**************************************************************************/ 
.................... void LM629_write_data(boolean controler, byte byte1) 
.................... { 
....................    if (controler){ 
0128:  MOVF   43,F
0129:  BTFSC  03,2
012A:  GOTO   134
....................       output_high(LM629_CS2);      // Desabilita o controlador 2 
012B:  BCF    2D,0
012C:  MOVF   2D,W
012D:  TRIS   7
012E:  BSF    07,0
....................       output_low(LM629_CS1);       // Habilita o controlador 1 
012F:  BCF    2D,1
0130:  MOVF   2D,W
0131:  TRIS   7
0132:  BCF    07,1
....................       } 
....................    else{ 
0133:  GOTO   13C
....................       output_high(LM629_CS1);      // Desabilita o controlador 1 
0134:  BCF    2D,1
0135:  MOVF   2D,W
0136:  TRIS   7
0137:  BSF    07,1
....................       output_low(LM629_CS2);       // Habilita o controlador 2 
0138:  BCF    2D,0
0139:  MOVF   2D,W
013A:  TRIS   7
013B:  BCF    07,0
....................       } 
....................    output_high(LM629_PS); 
013C:  MOVLW  E8
013D:  BSF    03,5
013E:  MOVWF  09
013F:  BCF    03,5
0140:  BSF    09,1
....................    SET_TRIS_D(0x00);         // PortD = Output 
0141:  MOVLW  00
0142:  BSF    03,5
0143:  MOVWF  08
....................    dados=byte1; 
0144:  BCF    03,5
0145:  MOVF   44,W
0146:  MOVWF  08
....................    output_low(LM629_WR); 
0147:  MOVLW  E8
0148:  BSF    03,5
0149:  MOVWF  09
014A:  BCF    03,5
014B:  BCF    09,0
....................    output_high(LM629_WR); 
014C:  BSF    03,5
014D:  MOVWF  09
014E:  BCF    03,5
014F:  BSF    09,0
....................    output_high(LM629_CS1); 
0150:  BCF    2D,1
0151:  MOVF   2D,W
0152:  TRIS   7
0153:  BSF    07,1
....................    output_high(LM629_CS2); 
0154:  BCF    2D,0
0155:  MOVF   2D,W
0156:  TRIS   7
0157:  BSF    07,0
0158:  RETLW  00
.................... } 
.................... 
.................... #INCLUDE "629cmd.c" 
....................  /**************************************************************************/ 
.................... /*        Comandos e procedimentos p/ LM629 - 629cmd.c                    */ 
.................... /* Autor: Marco Antonio Santuci Carvalho                                  */ 
.................... /* Ultima modificacao: 06/06/2000                                         */ 
.................... /* Descricao: Esta biblioteca de funcoes implementa funcoes de uso        */ 
.................... /*            do LM629 tais como leitura do byte de status e escritas no  */ 
.................... /*            barramento de comando e dados.                              */ 
.................... /**************************************************************************/ 
....................  
.................... /**************************************************************************/ 
.................... /*                 Declaração de constantes                               */ 
.................... /**************************************************************************/ 
.................... /* Constantes para o comando trajectory do LM629 */ 
....................  
.................... // byte 1 (MSB) 
.................... #DEFINE VEL_MODE_AND_FRENTE                  0x01 
.................... #DEFINE VEL_MODE_AND_TRAS                    0x11 
.................... #DEFINE VEL_MODE_AND_MOTOR_OFF_AND_FRENTE    0x00 
.................... #DEFINE VEL_MODE_AND_MOTOR_OFF_AND_TRAS      0x10 
.................... #DEFINE POS_MODE                             0x09 
.................... #DEFINE POS_MODE_AND_MOTOR_OFF               0x08 
....................  
.................... // Word 2 (LSB) 
.................... #DEFINE LOAD_ACEL                 0X20 
.................... #DEFINE LOAD_ACEL_AND_VEL         0X28 
.................... #DEFINE LOAD_ACEL_AND_VEL_AND_POS 0X2A 
.................... #DEFINE LOAD_VEL                  0X08 
.................... #DEFINE LOAD_VEL_AND_POS          0X0A 
.................... #DEFINE LOAD_POS                  0X02 
....................  
.................... /* Constantes para o comando LFIL do LM629 */ 
....................  
.................... #DEFINE LOAD_KP                   0X08 
.................... #DEFINE LOAD_KI                   0X04 
.................... #DEFINE LOAD_KD                   0X02 
.................... #DEFINE LOAD_KP_AND_KI            0X0C 
....................  
.................... /* Constantes de PWM */ 
.................... #DEFINE PWM_8                     0X05 
.................... #DEFINE PWM_16                    0X06 
....................  
.................... /* Nome dos comandos */ 
....................  
.................... #DEFINE  LFIL                     0x1E    // Load FILter 
.................... #DEFINE  STT                      0x01    // STarT 
.................... #DEFINE  LTRJ                     0x1F    // Load TRaJectory 
.................... #DEFINE  UDF                      0x04    // UpDate Filter 
.................... #DEFINE  RSTI                     0x1D    // ReSeT Interrupt 
.................... #DEFINE  RESET                    0x00    // Reset controler 
....................  
.................... /**************************************************************************/ 
.................... /* Rotina para checar bit busy do lm629                                   */ 
.................... /*                                                                        */ 
.................... /* Descricao: esta rotina checa o valor do bit busy no registrador de     */ 
.................... /*            status(bit 0).                                              */ 
.................... /**************************************************************************/ 
.................... boolean busy(boolean controler) // Le o bit busy 
.................... { 
....................  return (read_status(controler)&0x01); 
*
00EC:  MOVF   43,W
00ED:  MOVWF  44
00EE:  CALL   0AA
00EF:  MOVF   21,W
00F0:  ANDLW  01
00F1:  MOVWF  21
00F2:  RETLW  00
.................... } 
....................  
.................... /**************************************************************************/ 
.................... /* Rotina para atualização dos dados da trajetória                        */ 
.................... /*                                                                        */ 
.................... /* Descricao: esta rotina atualiza os parametros de trajetoria para cada  */ 
.................... /*            LM629 através do comando LTRJ(0x1F). Depois é passado uma   */ 
.................... /*            duas palavras de controle atraves das variaveis             */ 
.................... /*            trjt_ctrl_byte_1 e trjt_ctrl_byte_2.                        */ 
.................... /**************************************************************************/ 
.................... void atualiza_set_point(byte trjt_ctrl_byte_1, byte trjt_ctrl_byte_2) 
.................... { 
....................  
....................   // Controlador 1 
....................   while(busy(CTRL1)); 
*
0345:  MOVLW  01
0346:  MOVWF  43
0347:  CALL   0EC
0348:  MOVF   21,F
0349:  BTFSS  03,2
034A:  GOTO   345
....................   LM629_write_command(CTRL1, LTRJ);     // LTRJ Command: Load Trajectory Parameters 
034B:  MOVLW  01
034C:  MOVWF  43
034D:  MOVLW  1F
034E:  MOVWF  44
034F:  CALL   0F3
....................   while(busy(CTRL1)); 
0350:  MOVLW  01
0351:  MOVWF  43
0352:  CALL   0EC
0353:  MOVF   21,F
0354:  BTFSS  03,2
0355:  GOTO   350
....................   LM629_write_data(CTRL1, trjt_ctrl_byte_1); 
0356:  MOVLW  01
0357:  MOVWF  43
0358:  MOVF   40,W
0359:  MOVWF  44
035A:  CALL   128
....................   LM629_write_data(CTRL1, trjt_ctrl_byte_2); 
035B:  MOVLW  01
035C:  MOVWF  43
035D:  MOVF   41,W
035E:  MOVWF  44
035F:  CALL   128
....................  
....................   while(busy(CTRL1)); 
0360:  MOVLW  01
0361:  MOVWF  43
0362:  CALL   0EC
0363:  MOVF   21,F
0364:  BTFSS  03,2
0365:  GOTO   360
....................   LM629_write_data(CTRL1, 0); 
0366:  MOVLW  01
0367:  MOVWF  43
0368:  CLRF   44
0369:  CALL   128
....................   LM629_write_data(CTRL1, 0); 
036A:  MOVLW  01
036B:  MOVWF  43
036C:  CLRF   44
036D:  CALL   128
....................   while(busy(CTRL1)); 
036E:  MOVLW  01
036F:  MOVWF  43
0370:  CALL   0EC
0371:  MOVF   21,F
0372:  BTFSS  03,2
0373:  GOTO   36E
....................   LM629_write_data(CTRL1, 0); 
0374:  MOVLW  01
0375:  MOVWF  43
0376:  CLRF   44
0377:  CALL   128
....................   LM629_write_data(CTRL1, sp1_acel_serial); 
0378:  MOVLW  01
0379:  MOVWF  43
037A:  MOVF   36,W
037B:  MOVWF  44
037C:  CALL   128
....................  
....................   while(busy(CTRL1)); 
037D:  MOVLW  01
037E:  MOVWF  43
037F:  CALL   0EC
0380:  MOVF   21,F
0381:  BTFSS  03,2
0382:  GOTO   37D
....................   LM629_write_data(CTRL1, 0); 
0383:  MOVLW  01
0384:  MOVWF  43
0385:  CLRF   44
0386:  CALL   128
....................   LM629_write_data(CTRL1, 0); 
0387:  MOVLW  01
0388:  MOVWF  43
0389:  CLRF   44
038A:  CALL   128
....................   while(busy(CTRL1)); 
038B:  MOVLW  01
038C:  MOVWF  43
038D:  CALL   0EC
038E:  MOVF   21,F
038F:  BTFSS  03,2
0390:  GOTO   38B
....................   LM629_write_data(CTRL1, 0); 
0391:  MOVLW  01
0392:  MOVWF  43
0393:  CLRF   44
0394:  CALL   128
....................   LM629_write_data(CTRL1, sp1_vel_serial); 
0395:  MOVLW  01
0396:  MOVWF  43
0397:  MOVF   37,W
0398:  MOVWF  44
0399:  CALL   128
....................  
....................   while(busy(CTRL1)); 
039A:  MOVLW  01
039B:  MOVWF  43
039C:  CALL   0EC
039D:  MOVF   21,F
039E:  BTFSS  03,2
039F:  GOTO   39A
....................   LM629_write_data(CTRL1, 0); 
03A0:  MOVLW  01
03A1:  MOVWF  43
03A2:  CLRF   44
03A3:  CALL   128
....................   LM629_write_data(CTRL1, 0); 
03A4:  MOVLW  01
03A5:  MOVWF  43
03A6:  CLRF   44
03A7:  CALL   128
....................   while(busy(CTRL1)); 
03A8:  MOVLW  01
03A9:  MOVWF  43
03AA:  CALL   0EC
03AB:  MOVF   21,F
03AC:  BTFSS  03,2
03AD:  GOTO   3A8
....................   LM629_write_data(CTRL1, 0); 
03AE:  MOVLW  01
03AF:  MOVWF  43
03B0:  CLRF   44
03B1:  CALL   128
....................   LM629_write_data(CTRL1, sp1_pos_serial); 
03B2:  MOVLW  01
03B3:  MOVWF  43
03B4:  MOVF   38,W
03B5:  MOVWF  44
03B6:  CALL   128
....................   while(busy(CTRL1)); 
03B7:  MOVLW  01
03B8:  MOVWF  43
03B9:  CALL   0EC
03BA:  MOVF   21,F
03BB:  BTFSS  03,2
03BC:  GOTO   3B7
....................  
....................  
....................   // Controlador 2 
....................   while(busy(CTRL2)); 
03BD:  CLRF   43
03BE:  CALL   0EC
03BF:  MOVF   21,F
03C0:  BTFSS  03,2
03C1:  GOTO   3BD
....................   LM629_write_command(CTRL2, LTRJ);     // LTRJ Command: Load Trajectory Parameters 
03C2:  CLRF   43
03C3:  MOVLW  1F
03C4:  MOVWF  44
03C5:  CALL   0F3
....................   while(busy(CTRL2)); 
03C6:  CLRF   43
03C7:  CALL   0EC
03C8:  MOVF   21,F
03C9:  BTFSS  03,2
03CA:  GOTO   3C6
....................   LM629_write_data(CTRL2, trjt_ctrl_byte_1);        // carrega o 1 byte de configuracao 
03CB:  CLRF   43
03CC:  MOVF   40,W
03CD:  MOVWF  44
03CE:  CALL   128
....................   LM629_write_data(CTRL2, trjt_ctrl_byte_2);        // carrega o 2 byte de configuracao 
03CF:  CLRF   43
03D0:  MOVF   41,W
03D1:  MOVWF  44
03D2:  CALL   128
....................  
....................   while(busy(CTRL2)); 
03D3:  CLRF   43
03D4:  CALL   0EC
03D5:  MOVF   21,F
03D6:  BTFSS  03,2
03D7:  GOTO   3D3
....................   LM629_write_data(CTRL2, 0x00); 
03D8:  CLRF   43
03D9:  CLRF   44
03DA:  CALL   128
....................   LM629_write_data(CTRL2, sp2_acel_serial); 
03DB:  CLRF   43
03DC:  MOVF   39,W
03DD:  MOVWF  44
03DE:  CALL   128
....................   while(busy(CTRL2)); 
03DF:  CLRF   43
03E0:  CALL   0EC
03E1:  MOVF   21,F
03E2:  BTFSS  03,2
03E3:  GOTO   3DF
....................   LM629_write_data(CTRL2, 0x00); 
03E4:  CLRF   43
03E5:  CLRF   44
03E6:  CALL   128
....................   LM629_write_data(CTRL2, 0x00); 
03E7:  CLRF   43
03E8:  CLRF   44
03E9:  CALL   128
....................   while(busy(CTRL2)); 
03EA:  CLRF   43
03EB:  CALL   0EC
03EC:  MOVF   21,F
03ED:  BTFSS  03,2
03EE:  GOTO   3EA
....................  
....................   while(busy(CTRL2)); 
03EF:  CLRF   43
03F0:  CALL   0EC
03F1:  MOVF   21,F
03F2:  BTFSS  03,2
03F3:  GOTO   3EF
....................   LM629_write_data(CTRL2, 0x00); 
03F4:  CLRF   43
03F5:  CLRF   44
03F6:  CALL   128
....................   LM629_write_data(CTRL2, sp2_vel_serial); 
03F7:  CLRF   43
03F8:  MOVF   3A,W
03F9:  MOVWF  44
03FA:  CALL   128
....................   while(busy(CTRL2)); 
03FB:  CLRF   43
03FC:  CALL   0EC
03FD:  MOVF   21,F
03FE:  BTFSS  03,2
03FF:  GOTO   3FB
....................   LM629_write_data(CTRL2, 0x00); 
0400:  CLRF   43
0401:  CLRF   44
0402:  CALL   128
....................   LM629_write_data(CTRL2, 0x00); 
0403:  CLRF   43
0404:  CLRF   44
0405:  CALL   128
....................   while(busy(CTRL2)); 
0406:  CLRF   43
0407:  CALL   0EC
0408:  MOVF   21,F
0409:  BTFSS  03,2
040A:  GOTO   406
....................  
....................   while(busy(CTRL2)); 
040B:  CLRF   43
040C:  CALL   0EC
040D:  MOVF   21,F
040E:  BTFSS  03,2
040F:  GOTO   40B
....................   LM629_write_data(CTRL2, 0x00); 
0410:  CLRF   43
0411:  CLRF   44
0412:  CALL   128
....................   LM629_write_data(CTRL2, sp2_pos_serial); 
0413:  CLRF   43
0414:  MOVF   3B,W
0415:  MOVWF  44
0416:  CALL   128
....................   while(busy(CTRL2)); 
0417:  CLRF   43
0418:  CALL   0EC
0419:  MOVF   21,F
041A:  BTFSS  03,2
041B:  GOTO   417
....................   LM629_write_data(CTRL2, 0x00); 
041C:  CLRF   43
041D:  CLRF   44
041E:  CALL   128
....................   LM629_write_data(CTRL2, 0x00); 
041F:  CLRF   43
0420:  CLRF   44
0421:  CALL   128
....................   while(busy(CTRL2)); 
0422:  CLRF   43
0423:  CALL   0EC
0424:  MOVF   21,F
0425:  BTFSS  03,2
0426:  GOTO   422
0427:  RETLW  00
....................  
.................... } 
....................  
.................... /**************************************************************************/ 
.................... /* Rotina para movimentacao do motor                                      */ 
.................... /*                                                                        */ 
.................... /* Descricao: esta rotina executa o comando STT no controlador Lm629 que  */ 
.................... /*            faz com os parametros de trajetoria pre carregados sejam    */ 
.................... /*            executados.                                                  */ 
.................... /**************************************************************************/ 
.................... void run_motor() 
.................... { 
....................   while(busy(CTRL1)); 
0428:  MOVLW  01
0429:  MOVWF  43
042A:  CALL   0EC
042B:  MOVF   21,F
042C:  BTFSS  03,2
042D:  GOTO   428
....................   LM629_write_command(CTRL1, STT);   // Start Motion Control - Comando STT 
042E:  MOVLW  01
042F:  MOVWF  43
0430:  MOVWF  44
0431:  CALL   0F3
....................   while(busy(CTRL2)); 
0432:  CLRF   43
0433:  CALL   0EC
0434:  MOVF   21,F
0435:  BTFSS  03,2
0436:  GOTO   432
....................   LM629_write_command(CTRL2, STT);   // Start Motion Control - Comando STT 
0437:  CLRF   43
0438:  MOVLW  01
0439:  MOVWF  44
043A:  CALL   0F3
043B:  RETLW  00
.................... } 
....................  
....................  
.................... /**************************************************************************/ 
.................... /* Rotina para setar tamanho dos bits de PWM p/ motor                     */ 
.................... /*                                                                        */ 
.................... /* Descricao: esta rotina seta o tamanho da resolucao do PWM              */ 
.................... /*            que ira sera enviado para o driver do motor. Os tamanhos    */ 
.................... /*            possiveis são 8 e 16 bits                                   */ 
.................... /**************************************************************************/ 
.................... void seta_pwm(byte pwm_type) 
.................... { 
....................    while(busy(CTRL1)); 
*
026A:  MOVLW  01
026B:  MOVWF  43
026C:  CALL   0EC
026D:  MOVF   21,F
026E:  BTFSS  03,2
026F:  GOTO   26A
....................    LM629_write_command(CTRL1, pwm_type); 
0270:  MOVLW  01
0271:  MOVWF  43
0272:  MOVF   42,W
0273:  MOVWF  44
0274:  CALL   0F3
....................    while(busy(CTRL2)); 
0275:  CLRF   43
0276:  CALL   0EC
0277:  MOVF   21,F
0278:  BTFSS  03,2
0279:  GOTO   275
....................    LM629_write_command(CTRL2, pwm_type); 
027A:  CLRF   43
027B:  MOVF   42,W
027C:  MOVWF  44
027D:  CALL   0F3
.................... } 
....................  
....................  
.................... /**************************************************************************/ 
.................... /* Rotina para resetar o controlador LM629                                */ 
.................... /*                                                                        */ 
.................... /* Descricao: esta rotina reseta os controladores lm629 escrevendo 0x00   */ 
.................... /*            na portas de comando.                                       */ 
.................... /**************************************************************************/ 
.................... void rst_controlador(void) 
.................... { 
....................    while(busy(CTRL1)); 
*
0247:  MOVLW  01
0248:  MOVWF  43
0249:  CALL   0EC
024A:  MOVF   21,F
024B:  BTFSS  03,2
024C:  GOTO   247
....................    LM629_write_command(CTRL1, 0x00); 
024D:  MOVLW  01
024E:  MOVWF  43
024F:  CLRF   44
0250:  CALL   0F3
....................    while(busy(CTRL2)); 
0251:  CLRF   43
0252:  CALL   0EC
0253:  MOVF   21,F
0254:  BTFSS  03,2
0255:  GOTO   251
....................    LM629_write_command(CTRL2, 0x00); 
0256:  CLRF   43
0257:  CLRF   44
0258:  CALL   0F3
....................    delay_us(1500);             // Obrigatorio --> 1.5ms 
0259:  MOVLW  01
025A:  MOVWF  42
025B:  MOVF   0B,W
025C:  BCF    0B,7
025D:  MOVWF  25
025E:  CALL   03E
025F:  MOVF   25,W
0260:  IORWF  0B,F
0261:  MOVLW  02
0262:  MOVWF  42
0263:  MOVLW  EC
0264:  MOVWF  43
0265:  CALL   0E1
0266:  DECFSZ 42,F
0267:  GOTO   263
.................... } 
....................  
....................  
.................... /**************************************************************************/ 
.................... /* Rotina para resetar interrupcao do LM629                               */ 
.................... /*                                                                        */ 
.................... /* Descricao: esta rotina reseta as interrupcoes do LM629                 */ 
.................... /*                                                                        */ 
.................... /**************************************************************************/ 
.................... void reset_interrupt(byte irq) 
.................... { 
....................   while(busy(CTRL1)); 
*
027F:  MOVLW  01
0280:  MOVWF  43
0281:  CALL   0EC
0282:  MOVF   21,F
0283:  BTFSS  03,2
0284:  GOTO   27F
....................   LM629_write_command(CTRL1, RSTI); 
0285:  MOVLW  01
0286:  MOVWF  43
0287:  MOVLW  1D
0288:  MOVWF  44
0289:  CALL   0F3
....................   while(busy(CTRL1)); 
028A:  MOVLW  01
028B:  MOVWF  43
028C:  CALL   0EC
028D:  MOVF   21,F
028E:  BTFSS  03,2
028F:  GOTO   28A
....................   LM629_write_data(CTRL1, 0x00); 
0290:  MOVLW  01
0291:  MOVWF  43
0292:  CLRF   44
0293:  CALL   128
....................   LM629_write_data(CTRL1, irq); 
0294:  MOVLW  01
0295:  MOVWF  43
0296:  MOVF   42,W
0297:  MOVWF  44
0298:  CALL   128
....................   while(busy(CTRL2)); 
0299:  CLRF   43
029A:  CALL   0EC
029B:  MOVF   21,F
029C:  BTFSS  03,2
029D:  GOTO   299
....................   LM629_write_command(CTRL2, RSTI); 
029E:  CLRF   43
029F:  MOVLW  1D
02A0:  MOVWF  44
02A1:  CALL   0F3
....................   while(busy(CTRL2)); 
02A2:  CLRF   43
02A3:  CALL   0EC
02A4:  MOVF   21,F
02A5:  BTFSS  03,2
02A6:  GOTO   2A2
....................   LM629_write_data(CTRL2, 0x00); 
02A7:  CLRF   43
02A8:  CLRF   44
02A9:  CALL   128
....................   LM629_write_data(CTRL2, irq); 
02AA:  CLRF   43
02AB:  MOVF   42,W
02AC:  MOVWF  44
02AD:  CALL   128
.................... } 
....................  
.................... /**************************************************************************/ 
.................... /* Rotina para configuração dos ganhos dos controladores                  */ 
.................... /*                                                                        */ 
.................... /* Descricao: esta rotina carrega no controlador os ganhos kp, Ki e Kd    */ 
.................... /*            através do comando LFIL(0x1E). No comando é passado uma     */ 
.................... /*            palavra de configuração de 16 bits. Os primeiros 8 bits são */ 
.................... /*            intervalos de amostragem do ganho derivativo e por enquanto */ 
.................... /*            não sera utilizado. Os quatro bits menos significativos são */ 
.................... /*            usados para informar ao controlador que ganho será          */ 
.................... /*            carregado. O comando é aceito através da instrução Update   */ 
.................... /*            Filter - UDF(0x04).                                         */ 
.................... /**************************************************************************/ 
.................... void carrega_ganhos(byte lfil_ctrl_byte_2)  //antigo configura() 
.................... { 
....................   // Controlador 1 
....................   while(busy(CTRL1)); 
*
02C7:  MOVLW  01
02C8:  MOVWF  43
02C9:  CALL   0EC
02CA:  MOVF   21,F
02CB:  BTFSS  03,2
02CC:  GOTO   2C7
....................   LM629_write_command(CTRL1, LFIL);     // LFIL Command: Load Filter Parameters 
02CD:  MOVLW  01
02CE:  MOVWF  43
02CF:  MOVLW  1E
02D0:  MOVWF  44
02D1:  CALL   0F3
....................   while(busy(CTRL1)); 
02D2:  MOVLW  01
02D3:  MOVWF  43
02D4:  CALL   0EC
02D5:  MOVF   21,F
02D6:  BTFSS  03,2
02D7:  GOTO   2D2
....................   LM629_write_data(CTRL1, 0x00); 
02D8:  MOVLW  01
02D9:  MOVWF  43
02DA:  CLRF   44
02DB:  CALL   128
....................   LM629_write_data(CTRL1, lfil_ctrl_byte_2);   // byte de configuracao 
02DC:  MOVLW  01
02DD:  MOVWF  43
02DE:  MOVF   40,W
02DF:  MOVWF  44
02E0:  CALL   128
....................   while(busy(CTRL1)); 
02E1:  MOVLW  01
02E2:  MOVWF  43
02E3:  CALL   0EC
02E4:  MOVF   21,F
02E5:  BTFSS  03,2
02E6:  GOTO   2E1
....................   LM629_write_data(CTRL1, 0x0F);          //  Carrega o valor 
02E7:  MOVLW  01
02E8:  MOVWF  43
02E9:  MOVLW  0F
02EA:  MOVWF  44
02EB:  CALL   128
....................   LM629_write_data(CTRL1, kp);          //      de Kp 
02EC:  MOVLW  01
02ED:  MOVWF  43
02EE:  MOVF   33,W
02EF:  MOVWF  44
02F0:  CALL   128
....................   while(busy(CTRL1)); 
02F1:  MOVLW  01
02F2:  MOVWF  43
02F3:  CALL   0EC
02F4:  MOVF   21,F
02F5:  BTFSS  03,2
02F6:  GOTO   2F1
....................   LM629_write_data(CTRL1, 0x0F);          //  Carrega o valor 
02F7:  MOVLW  01
02F8:  MOVWF  43
02F9:  MOVLW  0F
02FA:  MOVWF  44
02FB:  CALL   128
....................   LM629_write_data(CTRL1, ki);          //      de Ki 
02FC:  MOVLW  01
02FD:  MOVWF  43
02FE:  MOVF   34,W
02FF:  MOVWF  44
0300:  CALL   128
....................   while(busy(CTRL1)); 
0301:  MOVLW  01
0302:  MOVWF  43
0303:  CALL   0EC
0304:  MOVF   21,F
0305:  BTFSS  03,2
0306:  GOTO   301
....................   LM629_write_command(CTRL1, UDF);      // Update Filter - comando UDF 
0307:  MOVLW  01
0308:  MOVWF  43
0309:  MOVLW  04
030A:  MOVWF  44
030B:  CALL   0F3
....................  
....................   // Controlador 2 
....................   while(busy(CTRL2)); 
030C:  CLRF   43
030D:  CALL   0EC
030E:  MOVF   21,F
030F:  BTFSS  03,2
0310:  GOTO   30C
....................   LM629_write_command(CTRL2, LFIL);     // LFIL Command: Load Filter Parameters 
0311:  CLRF   43
0312:  MOVLW  1E
0313:  MOVWF  44
0314:  CALL   0F3
....................   while(busy(CTRL2)); 
0315:  CLRF   43
0316:  CALL   0EC
0317:  MOVF   21,F
0318:  BTFSS  03,2
0319:  GOTO   315
....................   LM629_write_data(CTRL2, 0x00); 
031A:  CLRF   43
031B:  CLRF   44
031C:  CALL   128
....................   LM629_write_data(CTRL2, lfil_ctrl_byte_2);   // byte de configuracao 
031D:  CLRF   43
031E:  MOVF   40,W
031F:  MOVWF  44
0320:  CALL   128
....................   while(busy(CTRL2)); 
0321:  CLRF   43
0322:  CALL   0EC
0323:  MOVF   21,F
0324:  BTFSS  03,2
0325:  GOTO   321
....................   LM629_write_data(CTRL2, 0x0F);          //  Carrega o valor 
0326:  CLRF   43
0327:  MOVLW  0F
0328:  MOVWF  44
0329:  CALL   128
....................   LM629_write_data(CTRL2, kp);          //      de Kp 
032A:  CLRF   43
032B:  MOVF   33,W
032C:  MOVWF  44
032D:  CALL   128
....................   while(busy(CTRL2)); 
032E:  CLRF   43
032F:  CALL   0EC
0330:  MOVF   21,F
0331:  BTFSS  03,2
0332:  GOTO   32E
....................   LM629_write_data(CTRL2, 0x0F);          //  Carrega o valor 
0333:  CLRF   43
0334:  MOVLW  0F
0335:  MOVWF  44
0336:  CALL   128
....................   LM629_write_data(CTRL2, ki);          //      de Ki 
0337:  CLRF   43
0338:  MOVF   34,W
0339:  MOVWF  44
033A:  CALL   128
....................   while(busy(CTRL2)); 
033B:  CLRF   43
033C:  CALL   0EC
033D:  MOVF   21,F
033E:  BTFSS  03,2
033F:  GOTO   33B
....................   LM629_write_command(CTRL2, UDF);      // Update Filter - comando UDF 
0340:  CLRF   43
0341:  MOVLW  04
0342:  MOVWF  44
0343:  CALL   0F3
0344:  RETLW  00
.................... } 
....................  
.................... /**************************************************************************/ 
.................... /* Rotina para parar os motores                                           */ 
.................... /*                                                                        */ 
.................... /* Descricao: esta rotina programa os controladores para parar os motores */ 
.................... /*                                                                        */ 
.................... /**************************************************************************/ 
.................... void stop_motor(void) 
.................... { 
....................  
.................... // Controlador 1 
....................   while(busy(CTRL1)); 
*
0163:  MOVLW  01
0164:  MOVWF  43
0165:  CALL   0EC
0166:  MOVF   21,F
0167:  BTFSS  03,2
0168:  GOTO   163
....................   LM629_write_command(CTRL1, LTRJ);     // LTRJ Command: Load Trajectory Parameters 
0169:  MOVLW  01
016A:  MOVWF  43
016B:  MOVLW  1F
016C:  MOVWF  44
016D:  CALL   0F3
....................   while(busy(CTRL1)); 
016E:  MOVLW  01
016F:  MOVWF  43
0170:  CALL   0EC
0171:  MOVF   21,F
0172:  BTFSS  03,2
0173:  GOTO   16E
....................   LM629_write_data(CTRL1, 0x00);        // 0000 Bit11=1(velocity mode) Bit8=0(Turn Off Motor) 
0174:  MOVLW  01
0175:  MOVWF  43
0176:  CLRF   44
0177:  CALL   128
....................   LM629_write_data(CTRL1, LOAD_ACEL_AND_VEL_AND_POS);        // 0000  PRA DESLIGAR O MOTOR BIT8=0!!!!! 
0178:  MOVLW  01
0179:  MOVWF  43
017A:  MOVLW  2A
017B:  MOVWF  44
017C:  CALL   128
....................   //while(busy(CTRL1)); 
....................  
.................... while(busy(CTRL1)); 
017D:  MOVLW  01
017E:  MOVWF  43
017F:  CALL   0EC
0180:  MOVF   21,F
0181:  BTFSS  03,2
0182:  GOTO   17D
....................   LM629_write_data(CTRL1, 0); 
0183:  MOVLW  01
0184:  MOVWF  43
0185:  CLRF   44
0186:  CALL   128
....................   LM629_write_data(CTRL1, 0); 
0187:  MOVLW  01
0188:  MOVWF  43
0189:  CLRF   44
018A:  CALL   128
....................   while(busy(CTRL1)); 
018B:  MOVLW  01
018C:  MOVWF  43
018D:  CALL   0EC
018E:  MOVF   21,F
018F:  BTFSS  03,2
0190:  GOTO   18B
....................   LM629_write_data(CTRL1, 0); 
0191:  MOVLW  01
0192:  MOVWF  43
0193:  CLRF   44
0194:  CALL   128
....................   LM629_write_data(CTRL1, 0); 
0195:  MOVLW  01
0196:  MOVWF  43
0197:  CLRF   44
0198:  CALL   128
....................  
....................   while(busy(CTRL1)); 
0199:  MOVLW  01
019A:  MOVWF  43
019B:  CALL   0EC
019C:  MOVF   21,F
019D:  BTFSS  03,2
019E:  GOTO   199
....................   LM629_write_data(CTRL1, 0); 
019F:  MOVLW  01
01A0:  MOVWF  43
01A1:  CLRF   44
01A2:  CALL   128
....................   LM629_write_data(CTRL1, 0); 
01A3:  MOVLW  01
01A4:  MOVWF  43
01A5:  CLRF   44
01A6:  CALL   128
....................   while(busy(CTRL1)); 
01A7:  MOVLW  01
01A8:  MOVWF  43
01A9:  CALL   0EC
01AA:  MOVF   21,F
01AB:  BTFSS  03,2
01AC:  GOTO   1A7
....................   LM629_write_data(CTRL1, 0); 
01AD:  MOVLW  01
01AE:  MOVWF  43
01AF:  CLRF   44
01B0:  CALL   128
....................   LM629_write_data(CTRL1, 0); 
01B1:  MOVLW  01
01B2:  MOVWF  43
01B3:  CLRF   44
01B4:  CALL   128
....................  
....................   while(busy(CTRL1)); 
01B5:  MOVLW  01
01B6:  MOVWF  43
01B7:  CALL   0EC
01B8:  MOVF   21,F
01B9:  BTFSS  03,2
01BA:  GOTO   1B5
....................   LM629_write_data(CTRL1, 0); 
01BB:  MOVLW  01
01BC:  MOVWF  43
01BD:  CLRF   44
01BE:  CALL   128
....................   LM629_write_data(CTRL1, 0); 
01BF:  MOVLW  01
01C0:  MOVWF  43
01C1:  CLRF   44
01C2:  CALL   128
....................   while(busy(CTRL1)); 
01C3:  MOVLW  01
01C4:  MOVWF  43
01C5:  CALL   0EC
01C6:  MOVF   21,F
01C7:  BTFSS  03,2
01C8:  GOTO   1C3
....................   LM629_write_data(CTRL1, 0); 
01C9:  MOVLW  01
01CA:  MOVWF  43
01CB:  CLRF   44
01CC:  CALL   128
....................   LM629_write_data(CTRL1, 0); 
01CD:  MOVLW  01
01CE:  MOVWF  43
01CF:  CLRF   44
01D0:  CALL   128
....................   while(busy(CTRL1)); 
01D1:  MOVLW  01
01D2:  MOVWF  43
01D3:  CALL   0EC
01D4:  MOVF   21,F
01D5:  BTFSS  03,2
01D6:  GOTO   1D1
....................    
....................   // Inicia o controle 
....................   while(busy(CTRL1)); 
01D7:  MOVLW  01
01D8:  MOVWF  43
01D9:  CALL   0EC
01DA:  MOVF   21,F
01DB:  BTFSS  03,2
01DC:  GOTO   1D7
....................   LM629_write_command(CTRL1, STT);   // Start Motion Control - Comando STT 
01DD:  MOVLW  01
01DE:  MOVWF  43
01DF:  MOVWF  44
01E0:  CALL   0F3
....................  
....................  
....................   // Controlador 2 
....................   while(busy(CTRL2)); 
01E1:  CLRF   43
01E2:  CALL   0EC
01E3:  MOVF   21,F
01E4:  BTFSS  03,2
01E5:  GOTO   1E1
....................   LM629_write_command(CTRL2, LTRJ);     // LTRJ Command: Load Trajectory Parameters 
01E6:  CLRF   43
01E7:  MOVLW  1F
01E8:  MOVWF  44
01E9:  CALL   0F3
....................   while(busy(CTRL2)); 
01EA:  CLRF   43
01EB:  CALL   0EC
01EC:  MOVF   21,F
01ED:  BTFSS  03,2
01EE:  GOTO   1EA
....................   LM629_write_data(CTRL2, 0x00);        // 1000 Bit11=1(velocity mode) Bit8=0(Turn Off Motor) 
01EF:  CLRF   43
01F0:  CLRF   44
01F1:  CALL   128
....................   LM629_write_data(CTRL2, 0x00);        // 0000  PRA DESLIGAR O MOTOR BIT8=0!!!!! 
01F2:  CLRF   43
01F3:  CLRF   44
01F4:  CALL   128
....................   //while(busy(CTRL2)); 
....................  
....................  
....................   while(busy(CTRL2)); 
01F5:  CLRF   43
01F6:  CALL   0EC
01F7:  MOVF   21,F
01F8:  BTFSS  03,2
01F9:  GOTO   1F5
....................   LM629_write_command(CTRL2, STT);   // Start Motion Control - Comando STT 
01FA:  CLRF   43
01FB:  MOVLW  01
01FC:  MOVWF  44
01FD:  CALL   0F3
01FE:  RETLW  00
....................  
.................... } 
....................  
.................... /**************************************************************************/ 
.................... /* Rotina para inicialização do LM629                                     */ 
.................... /*                                                                        */ 
.................... /* Descricao: esta rotina é necessária para inicializar o controlador.    */ 
.................... /*            Primeiro é feito o reset por hardware atraves do pino de    */ 
.................... /*            RESET(27). Depois é feito o reset por software. Depois      */ 
.................... /*            o valor do registro de status eh checado e dependendo do    */ 
.................... /*            seu valor(0x84 ou 0xC4) o reset é considerado OK. Esta      */ 
.................... /*            rotina faz ainda o reset das interrupcoes do lm629.         */ 
.................... /**************************************************************************/ 
.................... void inicializa(void) 
.................... { 
....................   boolean reset_ok; 
....................   byte status; 
....................   output_high(LM629_RESET); 
01FF:  BCF    2D,2
0200:  MOVF   2D,W
0201:  TRIS   7
0202:  BSF    07,2
....................   reset_ok=FALSE; 
0203:  BCF    40,0
....................   output_low(LM629_RESET); 
0204:  BCF    2D,2
0205:  MOVF   2D,W
0206:  TRIS   7
0207:  BCF    07,2
....................   //rst_controlador(); 
....................   while(!reset_ok)   // Faz o reset dos controladores 
0208:  BTFSC  40,0
0209:  GOTO   243
....................     { 
....................       status=read_status(CTRL1); 
020A:  MOVLW  01
020B:  MOVWF  44
020C:  CALL   0AA
020D:  MOVF   21,W
020E:  MOVWF  41
....................       if ((status==0x84)||(status==0xC4)) // 0x84 - Bit7=1(Motor Off) Bit2=1(Trajectory Complete) 
020F:  MOVLW  84
0210:  SUBWF  41,W
0211:  BTFSC  03,2
0212:  GOTO   217
0213:  MOVLW  C4
0214:  SUBWF  41,W
0215:  BTFSS  03,2
0216:  GOTO   224
....................         {                                 // 0xC4 - Bit7=1(Motor Off) Bit6=1(Breakpoint Reached) 
....................           reset_ok=TRUE;                  //        Bit 2=1(Trajectory Complete) 
0217:  BSF    40,0
....................           status=read_status(CTRL2); 
0218:  CLRF   44
0219:  CALL   0AA
021A:  MOVF   21,W
021B:  MOVWF  41
....................           if (!((status==0x84)||(status==0xC4))) 
021C:  MOVLW  84
021D:  SUBWF  41,W
021E:  BTFSC  03,2
021F:  GOTO   224
0220:  MOVLW  C4
0221:  SUBWF  41,W
0222:  BTFSS  03,2
....................               reset_ok=TRUE; 
0223:  BSF    40,0
....................          } 
....................       if (!reset_ok) 
0224:  BTFSC  40,0
0225:  GOTO   242
....................          { 
....................           output_low(LM629_RESET); 
0226:  BCF    2D,2
0227:  MOVF   2D,W
0228:  TRIS   7
0229:  BCF    07,2
....................           delay_us(10);                 // Tem que esperar pelo menos 8 pulsos de clock 
022A:  MOVLW  10
022B:  MOVWF  20
022C:  DECFSZ 20,F
022D:  GOTO   22C
022E:  NOP
....................           output_high(LM629_RESET); 
022F:  BCF    2D,2
0230:  MOVF   2D,W
0231:  TRIS   7
0232:  BSF    07,2
....................           delay_us(1500);               // Obrigatorio--> 1.5ms 
0233:  MOVLW  01
0234:  MOVWF  42
0235:  MOVF   0B,W
0236:  BCF    0B,7
0237:  MOVWF  25
0238:  CALL   03E
0239:  MOVF   25,W
023A:  IORWF  0B,F
023B:  MOVLW  02
023C:  MOVWF  42
023D:  MOVLW  EC
023E:  MOVWF  43
023F:  CALL   0E1
0240:  DECFSZ 42,F
0241:  GOTO   23D
....................          } 
....................      } 
0242:  GOTO   208
....................    output_high(LM629_RESET); 
0243:  BCF    2D,2
0244:  MOVF   2D,W
0245:  TRIS   7
0246:  BSF    07,2
....................    rst_controlador(); 
....................    seta_pwm(PWM_8); 
*
0268:  MOVLW  05
0269:  MOVWF  42
....................    reset_interrupt(0x00); 
*
027E:  CLRF   42
....................    acende_led_verde(); 
*
02AE:  CALL   159
....................    delay_ms(10); 
02AF:  MOVLW  0A
02B0:  MOVWF  42
02B1:  MOVF   0B,W
02B2:  BCF    0B,7
02B3:  MOVWF  25
02B4:  CALL   03E
02B5:  MOVF   25,W
02B6:  IORWF  0B,F
....................    apaga_led_verde(); 
02B7:  CALL   15E
....................    stop_motor(); 
02B8:  CALL   163
02B9:  BCF    0A,3
02BA:  GOTO   48A
.................... } 
....................  
....................  
.................... /**************************************************************************/ 
.................... /* Rotina para codificar posicao recebida                                 */ 
.................... /*                                                                        */ 
.................... /* Descricao: esta rotina codifica o setpoint de posicao que eh recebido  */ 
.................... /*            pela serial                                                 */ 
.................... /*                                                                        */ 
.................... /**************************************************************************/ 
.................... void codifica_posicao(byte sp1, byte sp2) 
.................... { 
....................  
....................    //sp1_pos_serial=RESOLUCAO*sp1; 
....................    //sp2_pos_serial=RESOLUCAO*sp2; 
....................  
.................... } 
....................  
.................... /**************************************************************************/ 
.................... /* Rotina para codificar velocidade recebida                              */ 
.................... /*                                                                        */ 
.................... /* Descricao: esta rotina codifica o setpoint de velocidade que eh        */ 
.................... /*            recebido pela serial                                        */ 
.................... /*                                                                        */ 
.................... /**************************************************************************/ 
.................... void codifica_velocidade(byte sp1, byte sp2) 
.................... { 
....................  
....................    //sp1_vel_serial=(float)RESOLUCAO*sp1; 
....................    //sp2_vel_serial=(float)RESOLUCAO*sp2; 
....................  
.................... } 
....................  
.................... 
.................... #INCLUDE "eeprom.c" 
....................  /**************************************************************************/ 
.................... /*        Comandos e procedimentos p/ LM629 - eeprom.c                    */ 
.................... /* Autor: Marco Antonio Santuci Carvalho                                  */ 
.................... /* Ultima modificacao: 23/05/2000                                         */ 
.................... /* Descricao: Esta biblioteca de funcoes implementa funcoes de escrita    */ 
.................... /*            e leitura dos ganhos na memoria EEPROM.                      */ 
.................... /*                                                                        */ 
.................... /**************************************************************************/ 
....................  
....................  
....................  
.................... /**************************************************************************/ 
.................... /* Rotina para salvar ganhos na EEPROM                                    */ 
.................... /*                                                                        */ 
.................... /* Descricao:  salva os ganhos do controlador na EEPROM                  */ 
.................... /*                                                                        */ 
.................... /**************************************************************************/ 
.................... void salva_ganhos_EEPROM(void) 
.................... { 
....................   WRITE_EXT_EEPROM( 0x1, kp ); 
....................   WRITE_EXT_EEPROM( 0x2, ki ); 
....................   //WRITE_EXT_EEPROM( 0x3, kd ); 
.................... } 
....................  
.................... /**************************************************************************/ 
.................... /* Rotina para ler ganhos da EEPROM                                       */ 
.................... /*                                                                        */ 
.................... /* Descricao: le os ganhos kp, ki e kd da EEPROM                          */ 
.................... /*                                                                        */ 
.................... /**************************************************************************/ 
.................... void le_ganhos_EEPROM(void) 
.................... { 
....................   id=READ_EXT_EEPROM( 0x0 ); 
....................   kp=READ_EXT_EEPROM( 0x1 ); 
....................   ki=READ_EXT_EEPROM( 0x2 ); 
....................  // kd=READ_EXT_EEPROM( 0x3 ); 
....................  output_low(LED2_YELLOW);           // Acende Led amarelo 
.................... } 
.................... 
.................... #INCLUDE "serial.c" 
....................  /**************************************************************************/ 
.................... /*      Rotinas para tratamento dos dados da porta serial - serial.c      */ 
.................... /* Autor: Marco Antonio Santuci Carvalho                                  */ 
.................... /* Ultima modificacao: 23/05/2000                                         */ 
.................... /* Descricao: Esta biblioteca implementa funcoes para  tratamento dos     */ 
.................... /*            dados da porta serial. Um protocolo de comunicacao é        */ 
.................... /*            implementado.                                               */ 
.................... /**************************************************************************/ 
....................  
....................  
....................  
.................... void leserial(void)  // Le os dados da serial 
.................... { 
....................    output_low(LED2_YELLOW); 
....................    notrx=TRUE; 
....................    dados=getc(); 
....................    notrx=FALSE; 
....................    output_low(LED2_YELLOW); 
.................... } 
....................  
....................  
.................... boolean leucerto(void)  // Verifica o checksum e verifica a integridade 
.................... {                       // dos dados 
....................  setpoint=TRUE; 
....................  return TRUE; 
.................... } 
....................  
....................  
....................  
.................... 
....................  
.................... #use fast_io(D)  // diretiva para PORTD ficar mais rapido 
....................  
.................... /***********************************************************************/ 
.................... /*                          Interrupcoes                               */ 
.................... /***********************************************************************/ 
....................  
.................... // Timer0 (RTCC) overflow 
.................... #int_rtcc 
.................... rtcc_isr() { 
....................         //battery_check(); 
....................         if(--time_exec==0) 
*
0051:  DECFSZ 3C,F
0052:  GOTO   060
....................         { 
....................          output_high(LED1_RED); 
0053:  BSF    03,5
0054:  BCF    06,1
0055:  BCF    03,5
0056:  BSF    06,1
....................          delay_ms(100); 
0057:  MOVLW  64
0058:  MOVWF  42
0059:  CALL   03E
....................          output_low(LED1_RED); 
005A:  BSF    03,5
005B:  BCF    06,1
005C:  BCF    03,5
005D:  BCF    06,1
....................          time_exec=MAX_TIME; 
005E:  MOVLW  64
005F:  MOVWF  3C
....................         } 
0060:  BCF    0B,2
0061:  BCF    0A,3
0062:  GOTO   026
.................... } 
....................  
.................... // Async Serial Data In 
.................... /*#int_rda 
.................... rda_isr() { 
....................  
....................     //recebe_dados(); 
....................  
....................        disable_interrupts(GLOBAL); 
....................        output_low(LED3_GREEN);            // Acende Led verde 
....................        delay_ms(10); 
....................        output_high(LED3_GREEN);           // Apaga Led verde 
....................        dados=getc(); 
....................        enable_interrupts(INT_TIMER1); 
....................        enable_interrupts(INT_RDA); 
.................... 	    enable_interrupts(GLOBAL); 
....................  
.................... }*/ 
....................  
....................  
.................... /***********************************************************************/ 
.................... /*                            Função MAIN                              */ 
.................... /***********************************************************************/ 
....................  
.................... main() { 
*
043C:  CLRF   04
043D:  CLRF   03
043E:  MOVLW  9F
043F:  MOVWF  04
0440:  MOVLW  07
0441:  MOVWF  00
0442:  MOVLW  20
0443:  BSF    03,5
0444:  MOVWF  19
0445:  MOVLW  22
0446:  MOVWF  18
0447:  MOVLW  90
0448:  BCF    03,5
0449:  MOVWF  18
044A:  MOVLW  FF
044B:  MOVWF  2D
044C:  BCF    32,4
....................  
.................... /***********************************************************************/ 
.................... /*                     Configuração do PIC                             */ 
.................... /***********************************************************************/ 
....................    set_rtcc(0); 
044D:  CLRF   01
.................... 	setup_counters(RTCC_INTERNAL,RTCC_DIV_256); //Timer 0 c/ clock interno div/256--> estouro a cada 65.53ms 
044E:  MOVLW  07
044F:  MOVWF  20
0450:  BTFSS  20,3
0451:  GOTO   45A
0452:  MOVLW  07
0453:  CLRF   01
0454:  MOVLW  81
0455:  MOVWF  04
0456:  MOVF   00,W
0457:  ANDLW  C0
0458:  IORLW  0F
0459:  MOVWF  00
045A:  CLRWDT
045B:  MOVLW  81
045C:  MOVWF  04
045D:  MOVF   00,W
045E:  ANDLW  C0
045F:  IORWF  20,W
0460:  MOVWF  00
....................  
....................    setup_port_a(RA0_RA1_RA3_ANALOG); 
0461:  MOVLW  9F
0462:  MOVWF  04
0463:  MOVLW  04
0464:  MOVWF  00
....................    setup_adc(ADC_CLOCK_INTERNAL); 
0465:  MOVF   1F,W
0466:  ANDLW  38
0467:  IORLW  C1
0468:  MOVWF  1F
....................  
....................  
....................    enable_interrupts(RTCC_ZERO);     // habilita interrupcao Timer0 
0469:  BSF    0B,5
.................... 	//enable_interrupts(INT_RDA);       // habilita interrupcao porta serial 
.................... 	enable_interrupts(GLOBAL);        // habilita interrupcao Global 
046A:  MOVLW  C0
046B:  IORWF  0B,F
....................  
....................    //disable_interrupts(GLOBAL); 
....................  
....................    port_b_pullups(TRUE);             // habilita resistores pull ups PortB 
046C:  MOVLW  81
046D:  MOVWF  04
046E:  BCF    00,7
....................  
....................    init_ext_eeprom();                // Procedimento de inicializacao da memoria EEPROM 
046F:  GOTO   063
....................  
....................    SET_TRIS_D(ALL_OUT);    // PORTD = Output 
0470:  MOVLW  00
0471:  BSF    03,5
0472:  MOVWF  08
....................  
....................    output_high(LM629_CS1);    // 
0473:  BCF    03,5
0474:  BCF    2D,1
0475:  MOVF   2D,W
0476:  TRIS   7
0477:  BSF    07,1
....................    output_high(LM629_CS2);    // 
0478:  BCF    2D,0
0479:  MOVF   2D,W
047A:  TRIS   7
047B:  BSF    07,0
....................    output_high(LM629_RD);     //  Desabilita pinos de controle 
047C:  BSF    03,5
047D:  BCF    05,5
047E:  BCF    03,5
047F:  BSF    05,5
....................    output_high(LM629_WR);     // 
0480:  MOVLW  E8
0481:  BSF    03,5
0482:  MOVWF  09
0483:  BCF    03,5
0484:  BSF    09,0
....................    output_high(LM629_PS);     // 
0485:  BSF    03,5
0486:  MOVWF  09
0487:  BCF    03,5
0488:  BSF    09,1
....................  
.................... /***********************************************************************/ 
.................... /*                     Boot da placa                                   */ 
.................... /***********************************************************************/ 
....................  
.................... inicializa(); 
0489:  GOTO   1FF
....................  
.................... //teste da interrupcao 
.................... time_exec=MAX_TIME; 
048A:  MOVLW  64
048B:  MOVWF  3C
....................  
.................... kp=0xFF; 
048C:  MOVLW  FF
048D:  MOVWF  33
.................... ki=0xFF; 
048E:  MOVWF  34
.................... //carrega_ganhos(LOAD_KP_AND_KI); 
....................  
.................... delay_ms(2000); 
048F:  MOVLW  08
0490:  MOVWF  40
0491:  MOVLW  FA
0492:  MOVWF  42
0493:  MOVF   0B,W
0494:  BCF    0B,7
0495:  MOVWF  25
0496:  CALL   03E
0497:  MOVF   25,W
0498:  IORWF  0B,F
0499:  DECFSZ 40,F
049A:  GOTO   491
....................  
.................... acende_led_amarelo(); 
049B:  GOTO   2BB
.................... stop_motor(); 
049C:  CALL   163
.................... stop_motor(); 
049D:  CALL   163
....................  
.................... delay_ms(2000); 
049E:  MOVLW  08
049F:  MOVWF  40
04A0:  MOVLW  FA
04A1:  MOVWF  42
04A2:  MOVF   0B,W
04A3:  BCF    0B,7
04A4:  MOVWF  25
04A5:  CALL   03E
04A6:  MOVF   25,W
04A7:  IORWF  0B,F
04A8:  DECFSZ 40,F
04A9:  GOTO   4A0
....................  
.................... //sp1_acel_serial=0xF0; 
.................... //sp2_acel_serial=0XF0; 
....................  
.................... //sp1_vel_serial=0XFF; 
.................... //sp2_vel_serial=0XFF; 
....................  
.................... //sp1_pos_serial=0XFF; 
.................... //sp2_pos_serial=0XFF; 
....................  
.................... //inicia_leds(); 
....................  
.................... //carrega_ganhos(LOAD_KP_AND_KI); 
.................... //stop_motor(); 
.................... //delay_ms(1000); 
.................... //atualiza_set_point(VEL_MODE_AND_MOTOR_OFF_AND_FRENTE,LOAD_ACEL_AND_VEL_AND_POS); 
.................... //run_motor(); 
....................  
.................... apaga_led_amarelo(); 
04AA:  GOTO   2C1
....................  
.................... sp1_acel_serial=0X0F; 
04AB:  MOVLW  0F
04AC:  MOVWF  36
.................... sp2_acel_serial=0XFF; 
04AD:  MOVLW  FF
04AE:  MOVWF  39
....................  
.................... sp1_vel_serial=0X03; 
04AF:  MOVLW  03
04B0:  MOVWF  37
.................... sp2_vel_serial=0X01; 
04B1:  MOVLW  01
04B2:  MOVWF  3A
....................  
.................... carrega_ganhos(LOAD_KP_AND_KI); 
04B3:  MOVLW  0C
04B4:  MOVWF  40
04B5:  CALL   2C7
.................... delay_ms(1); 
04B6:  MOVLW  01
04B7:  MOVWF  42
04B8:  MOVF   0B,W
04B9:  BCF    0B,7
04BA:  MOVWF  25
04BB:  CALL   03E
04BC:  MOVF   25,W
04BD:  IORWF  0B,F
.................... atualiza_set_point(VEL_MODE_AND_TRAS ,LOAD_ACEL_AND_VEL); 
04BE:  MOVLW  11
04BF:  MOVWF  40
04C0:  MOVLW  28
04C1:  MOVWF  41
04C2:  CALL   345
.................... delay_ms(1); 
04C3:  MOVLW  01
04C4:  MOVWF  42
04C5:  MOVF   0B,W
04C6:  BCF    0B,7
04C7:  MOVWF  25
04C8:  CALL   03E
04C9:  MOVF   25,W
04CA:  IORWF  0B,F
.................... run_motor(); 
04CB:  CALL   428
....................  
.................... acende_led_verde(); 
04CC:  CALL   159
....................  
.................... delay_ms(5000); 
04CD:  MOVLW  14
04CE:  MOVWF  40
04CF:  MOVLW  FA
04D0:  MOVWF  42
04D1:  MOVF   0B,W
04D2:  BCF    0B,7
04D3:  MOVWF  25
04D4:  CALL   03E
04D5:  MOVF   25,W
04D6:  IORWF  0B,F
04D7:  DECFSZ 40,F
04D8:  GOTO   4CF
.................... stop_motor(); 
04D9:  CALL   163
.................... delay_ms(5000); 
04DA:  MOVLW  14
04DB:  MOVWF  40
04DC:  MOVLW  FA
04DD:  MOVWF  42
04DE:  MOVF   0B,W
04DF:  BCF    0B,7
04E0:  MOVWF  25
04E1:  CALL   03E
04E2:  MOVF   25,W
04E3:  IORWF  0B,F
04E4:  DECFSZ 40,F
04E5:  GOTO   4DC
....................  
.................... carrega_ganhos(LOAD_KP_AND_KI); 
04E6:  MOVLW  0C
04E7:  MOVWF  40
04E8:  CALL   2C7
.................... delay_ms(1); 
04E9:  MOVLW  01
04EA:  MOVWF  42
04EB:  MOVF   0B,W
04EC:  BCF    0B,7
04ED:  MOVWF  25
04EE:  CALL   03E
04EF:  MOVF   25,W
04F0:  IORWF  0B,F
.................... atualiza_set_point(VEL_MODE_AND_FRENTE,LOAD_ACEL_AND_VEL); 
04F1:  MOVLW  01
04F2:  MOVWF  40
04F3:  MOVLW  28
04F4:  MOVWF  41
04F5:  CALL   345
.................... delay_ms(1); 
04F6:  MOVLW  01
04F7:  MOVWF  42
04F8:  MOVF   0B,W
04F9:  BCF    0B,7
04FA:  MOVWF  25
04FB:  CALL   03E
04FC:  MOVF   25,W
04FD:  IORWF  0B,F
.................... run_motor(); 
04FE:  CALL   428
....................  
....................  
.................... apaga_led_verde(); 
04FF:  CALL   15E
....................  
.................... stop_motor(); 
0500:  CALL   163
.................... while(1); 
0501:  GOTO   501
.................... } 
....................  
0502:  SLEEP
....................  
